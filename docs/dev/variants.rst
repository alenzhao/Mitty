.. _variation_struct:

Genome simulation
=================
There are two kinds of genome simulations:

  * site frequency spectrum sampled population (Sampled)
  * detailed forward simulation population (Forward)

The `Sampled` simulation is generated by creating a large list of potential variants and then selecting, with replacement,
from this list, to create a chromosome. This is done twice per sample to create a diploid genome. Each variant has a
probability (:math:`p_i`) of appearing in a sample. The distribution of :math:`p_i` is called the site frequency spectrum.
The probability for a heterozygous variant is :math:`p_i^2`

A `Forward` simulation starts with a population generated by Sampling and is then carried forward, generation by
generation using models of sexual reproduction, including recombination of chromosomes.

Population Variant master list
------------------------------
The main simulation asks each variant plugin for a list of candidate variants that are then stored in a sorted master
list of variants. Each variant has an associated probability of it appearing in any given chromosome. The distribution of the
probabilities follow the shape given by the site frequency spectrum models.

For the Single and Sampled simulations we select variants (with replacement, for each chromosome) from this list to create
new chromosomes. For Single and Sampled simulations we select variants from the whole list.

For Forward simulations, the founder population is created using the Sampled simulation algorithm but by restricting
the variant selection to those having a certain minimum probability value. These initial variants are then marked off the
list. Subsequent generations add the remaining lower probability variants without replacement. The simulation will
terminate when we run out of variants or when the required number of generations have been run.


Data structures
===============

Internally, a variant is represented by a light-weight container called :py:class:`mitty.lib.variation.Variant`. All the
variants are represented in a master list sorted by pos value.

A chromosome is represented as a linked list of a :py:class:`mitty.lib.variation.GTVariant`. When we do operations on
a chromosome of a sample we always go through each variant sequentially, so this is a good data structure for our use
case.

Storage
=======
The results of the simulation are stored in a sqlite database. We can write VCFs from this database and the read generator
can read genomes directly off this database to generate reads.


Detailed Algorithms
===================

Site frequency spectrum
-----------------------


Selecting variants from the master list
---------------------------------------

UPDATE!!!!!

We have V variants in our master list, and each variant has an associated probability p_k of being included in a
sample (k=0, 1, .... V-1). The distribution of p_k follows the site frequency spectrum, as discussed above.

In principle we would generate N random numbers from a uniform distribution between 0.0 and 1.0 and use that to
decide whether each individual variant is selected for a sample or not. In practice N can be 10 million or more and so
we look to reduce our computational costs.

We quantize the x-axis (variant probability) of the site frequency spectrum into M levels (p_i, i=0,1,2 ... M-1) each
with v_i variants. V=sum(v_i) i=0,1,2 ... M-1. Since each variant in a given probability bucket has the same p_i value
we can use a poisson model to pick variants from each bucket without having to go through each individual variant.
This dramatically reduces our selection cost and makes it proportional to the number of variants/sample individual, rather
than proportional to the number of variants in the master list.

As a side note, sum(p_i * v_i) = E(variants in a sample).

We create the master list from all the variants from all the variant generators and then sort it by position. We then
create M arrays with `indexes` of the variants that fall into a given probability bin. Each array is sorted by
probability value, and then all the arrays are re-balanced so that the distribution now follows the ideal site frequency
distribution. (We sort the arrays first because we want to maintain the rank-ordering of the points even after re-balancing)

We then run M separate poisson searches to pick indexes from each bucket. We combine and sort the indexes and then
create the candidate chromosome by ensuring none of the variants clash with each other, and merging any homozygous
variants as needed.

TODO: Detailed description of Forward sim.

Variant plugins
===============
The main simulation engine passes the following parameters to a variant plugin::

    Chromosome  - indicates which chromosome is being simulated
    start, stop - indicates the coordinate range, along this chromosome, that is being simulated
    ref         - the reference sequence of this chromosome as a string
    p, f        - the site frequency spectrum the simulation is using.


The variant plugin returns a list of variations. Each returned variation should have an associated probability value
to indicate the relative rarity of the mutation. An extremely rare mutation should have a
value close to 0.0 while an extremely common one should have a value of 0.1 or so. These values are re-normalized by the
simulation so that the overall site frequency spectrum of all generated variants follows the required site frequency spectrum.

In addition to the above parameters, a variant plugin may take a custom list of parameters (such as mutation rate) for
a one time initialization.


Future directions
-----------------
Can generate linkage by picking neighboring variants, rather than arbitrary variants