Mitty is a collection of modules and scripts that enable us to generate simulated genomic data to test our algorithms.
The scripts allow us to simulate mutations on a reference sequence/genome and then simulate reads from that mutated
sequence/genome.

    Reference
     genome
       |-----------> chrom 1  ----> strand 0
       |                      \---> strand 1
       |-----------> chrom 2  ----> strand 0
       |                      \---> strand 1
          .....


                       +

                VCF generated by Mitty

                       =

    Mutated
     genome
       |-----------> chrom 1  ----> strand 0
       |                      \---> strand 1
       |-----------> chrom 2  ----> strand 0
       |                      \---> strand 1
          .....

                        |
                        | artificial reads
                        |
                        V
                   -  -  - -_ - __ - - --
               _-_-_-- - -_ - _ -- -_ -
                 -_ -_- - _ - _ - - -    -
                          /
                         /
                     qname = 'r22:23:25M25I25M'
                         \
                         \
      ----------------------------------------------
                  perfect alignment


Conceptually, Mitty generates simulated data by starting from a reference genome, adding controlled mutations to it and
then generating reads from the chromosomes of the mutated genome. Since we know where the reads came from, we can
perfectly align them back onto the original genome.

**The data generated by Mitty can, therefore, be used to test the correctness of aligners and variant callers under
different conditions and data set characteristics.**

Mitty, at its heart, is a set of Python programs that can be run from the commandline. Mitty has, additionally, been
wrapped for the Seven Bridges Genomics computation platform (IGOR). We will start with a conceptual overview of Mitty
components which closely mirrors how you would graphically create a data simulation pipeline on IGOR. After that we will
go over how to run Mitty components directly from the commandline.

Quickstart: Running Mitty on the Seven Bridges Platform
=======================================================

The process for running Mitty components to create reads from a mutated genome starting from only a reference
sequence is illustrated schematically below.


                    ----------
         fasta     |          |---> smalla file
          file --->| converta |
                   |          |---> heada file
                    ----------

We start with reference sequence data stored in a fasta file. For efficiency purposes we strip the header and all new lines
out of the original .fasta file. The resulting file is called a .smalla file and is what the rest of the tools
use. This conversion can be done easily using the converta.py script. The header is saved into a .smalla.heada file.


                    mutation
                   parameters
                       |
                       V
                    --------
                   |        |----> VCF, VCF.gz, VCF.gz.tbi
       ref seq --->| mutate |
                   |        |----> side car file with sim params
                    --------

Given a set of mutation instructions we can use `mutate.py` to generate a VCF file. For further processing `mutate.py`
compresses the VCF file using `bgzip` and indexes it using `tabix`.


                    ---------
       ref seq --->|         |---> seq_0, seq_1, ... (depending on requested ploidy)
                   | vcf2seq |
       VCF.gz  --->|         |---> pos file
                    ---------

Using the `vcf2seq` tool we can write out the mutations indicated by VCF into a complete mutated sequence saved as a
set of .smalla files. The number of .smalla files depends on the ploidy we request.
We also save a `pos` file which is used by `reads.py` (see below) for writing correct CIGAR strings for each read.


                     read
                   parameters
                       |
                       V
          seq_0     --------
          seq_1    |        |----> corrupted ("real") reads (BAM/FASTQ) if requested.
           ... --->|        |
                   | reads  |----> ideal reads (BAM/FASTQ)
          pos_0 -->|        |
          pos_1    |        |----> side car file with sim params
           ...      --------

The `reads` tool enables us to take a sequence and generate simulated reads from it. The reads can
       simulate various error and property profiles of different sequencers. Each read carries, in its qname field,
       a read serial number and POS and CIGAR strings that can be used to recreate perfect alignments of the reads to
       the original reference. This information is useful for diagnosing the performance of aligners and variant
       callers.


                    ----------
                   |          |
          BAM  --->|  cheata  |---> BAM file with perfect alignments
                   |          |
                    ----------

The `cheata` tool takes a simulated BAM file generated by `reads.py` and uses the POS and CIGAR information stored in
the qname field to generate a perfectly aligned BAM file.


Mitty on the commandline
========================

**Each module is designed to run as a script. Typing `python mutate.py -h` or simply `python mutate.py` etc. will list
usage and input requirements. Most scripts have built in tests which can be run by typing `test` or `test -v` after
command invocation, like `python mutate.py test -v`**


Test as you read
----------------

**This document contains doctest strings! Running `python -m doctest -v Readme.md` will run all the code snippets you
see here and make sure Mitty is doing what it is supposed to be. All the generated data files are left under README-DATA**

In order to run the command line code within the examples, without getting messy, we define a function `shell` that
gets python to properly call the shell command we would have used. It is a bit like IPython's `%run` magic command.

    >>> import shlex, subprocess
    >>> def shell(command): subprocess.call(shlex.split(command))
    >>> def shelly(command): _ = subprocess.call(command, shell=True)

We also don't want to clutter up our workspace with a [plethora][pleth] of generated files, so we create a temporary directory to
store created data files in. We don't delete this directory at the end, in case you want to take a look at the files at
your leisure. **We do clear out this directory every time we run.**

    >>> shell('mkdir -p README-DATA')
    >>> shell('rm README-DATA/*')

[pleth]: https://www.youtube.com/watch?v=tyBUMntP6DI

Generating simulated variations
===============================

In the following examples we will use the porcine circovirus sequence ([porcine_circovirus.fa][1]), which is 702b long,
as a reference sequence. In some experiments we may use the adenovirus sequence ([adenovirus.fa][2]), which is slightly
longer at 34094b. Both the sequences are found under the `Data` directory.

[1]: http://www.ncbi.nlm.nih.gov/nuccore/AY735451.1
[2]: http://www.ncbi.nlm.nih.gov/nuccore/AB026117.1

Converta
--------
We use converta to reorganize sequence data in .fasta files so that Mitty's routines can use them. (Dev note: basically,
by stripping out the header and newlines from the .fasta file the .smalla file can be easily used as a disk mapped
array - via mmap - so we can handle large sequences without loading it into memory all at once)

    >>> shell('python converta.py Data/porcine_circovirus.fa README-DATA/porcine_circovirus')
    >>> with open('README-DATA/porcine_circovirus_0.smalla','r') as f: print f.read()
    ATGACGTATCCAAGGAGGCGTTACCGGAGAAGAAGACACCGCCCCCGCAGCCATCTTGGCCAGATCCTCCGCCGCCGCCCCTGGCTCGTCCACCCCCGCCACCGTTACCGCTGGAGAAGGAAAAACGGCATCTTCAACACCCGCCTCTCCCGCACCTTCGGATATACTATCAAGCGAACCACAGTCAAAACGCCCTCCTGGGCGGTGGACATGATGAGATTCAATATTAATGACTTTCTTCCCCCAGGAGGGGGCTCAAACCCCCGCTCTGTGCCCTTTGAATACTACAGAATAAGAAAGGTTAAGGTTGAATTCTGGCCCTGCTCCCCGATCACCCAGGGTGACAGGGGAGTGGGCTCCAGTGCTGTTATTCTAGATGATAACTTTGTAACAAAGGCCACAGCCCTCACCTATGACCCCTATGTAAACTACTCCTCCCGCCATACCATAACCCAGCCCTTCTCCTACCACTCCCGCTACTTTACCCCCAAACCTGTCCTAGATTCCACTATTGATTACTTCCAACCAAACAACAAAAGAAATCAGCTGTGGCTGAGACTACAAACTGCTGGAAATGTAGACCACGTAGGCCTCGGCACTGCGTTCGAAAACAGTATATACGACCAGGAATACAATATCCGTGTAACCATGTATGTACAATTCAGAGAATTTAATCTTAAAGACCCCCCACTTAACCCTTAG
    >>> with open('README-DATA/porcine_circovirus_0.smalla.heada','r') as f: print f.read()
    gi|52547303|gb|AY735451.1| Porcine circovirus isolate Hebei capsid protein gene, complete cds
    702

Mutate
------
We use mutate, in combination with a mutation parameter file, to generate a VCF file. The `-v` flag causes `mutate.py` to
give a running commentary as it works, which is useful to see if everything is going well.

We will start with a simple experiment where we insert a few SNPs into the porcine circovirus sequence

    >>> import json
    >>> json.dump(
    ... {
    ...      "input smalla file": "README-DATA/porcine_circovirus_0.smalla",
    ...      "output vcf file": "README-DATA/variants.vcf",
    ...      "chromosome": "1",
    ...      "mutations": {
    ...          "snp": {
    ...              "model": "snp",
    ...              "start_snps_frac": 0.1,
    ...              "stop_snps_frac":  0.3,
    ...              "phet": 0.5,
    ...              "p": 0.01,
    ...              "het_rng_seed":3,
    ...              "strand_rng_seed": 4,
    ...              "poisson_rng_seed": 1,
    ...              "base_sub_rng_seed": 2
    ...          }
    ...      }
    ...  }, open('README-DATA/mutations1.json','w'), indent=2)
    >>> shell('python mutate.py --paramfile=README-DATA/mutations1.json  -v')

(For a detailed description of the stock plugin parameters you can run the plugin as a script with the `explain` command,
e.g. `python Plugins/Mutation/insert_plugin.py explain`).

You should see something like:

    DEBUG:__main__:Input sequence: README-DATA/porcine_circovirus_0.smalla
    DEBUG:__main__:Input sequence has 702 bases
    DEBUG:__main__:Output file name: README-DATA/variants.vcf
    DEBUG:__main__:100% done
    DEBUG:__main__:Generated 1 snps
    DEBUG:__main__:Compressing and indexing VCF file

You can take a look at the generated VCF file:

    >>> with open('README-DATA/variants.vcf','r') as f: print f.read()  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ##fileformat=VCFv4.1
    ##fileDate=...
    ##source=...
    ##reference=porcine_circovirus_0.smalla
    #CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	sample
    1	169	.	A	T	96	PASS	.	GT	1/1
    <BLANKLINE>

Mutate is smart enough not to overlay multiple variants. Consider the following parameter file that generates SNPs
uniformly across the sequence

    >>> json.dump(
    ... {
    ...      "input smalla file": "README-DATA/porcine_circovirus_0.smalla",
    ...      "output vcf file": "README-DATA/variants.vcf",
    ...      "chromosome": "1",
    ...      "mutations": {
    ...          "snp": {
    ...              "model": "snp",
    ...              "start_snps_frac": 0.0,
    ...              "stop_snps_frac":  1.0,
    ...              "phet": 0.0,
    ...              "p": 0.01,
    ...              "poisson_rng_seed": 1,
    ...              "base_sub_rng_seed": 2
    ...          }
    ...      }
    ...  }, open('README-DATA/mutations2.json','w'), indent=2)

(Note that you can leave out parameters. In general, programs in Mitty will fill out missing parameters with defaults. In
this case we left out the `het_rng_seed` but `phet=0.0` means that we don't need that anyway.)

Let's take a look at the resulting VCF file:

    >>> shell('python mutate.py --paramfile=README-DATA/mutations2.json')
    >>> with open('README-DATA/variants.vcf','r') as f: print f.read()  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ##fileformat=VCFv4.1
    ##fileDate=...
    ##source=...
    ##reference=porcine_circovirus_0.smalla
    #CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  sample
    1       99      .       C       G       96      PASS    .       GT      1/1
    1       187     .       A       C       96      PASS    .       GT      1/1
    1       277     .       T       C       96      PASS    .       GT      1/1
    1       374     .       T       A       96      PASS    .       GT      1/1
    1       472     .       T       A       96      PASS    .       GT      1/1
    1       570     .       T       C       96      PASS    .       GT      1/1
    1       657     .       A       G       96      PASS    .       GT      1/1
    <BLANKLINE>

Consider the following parameter file that generates deletes uniformly across the sequence


    >>> json.dump(
    ... {
    ...      "input smalla file": "README-DATA/porcine_circovirus_0.smalla",
    ...      "output vcf file": "README-DATA/variants.vcf",
    ...      "chromosome": "1",
    ...      "mutations": {
    ...          "delete": {
    ...              "model": "delete",
    ...              "start_dels_frac": 0.0,
    ...              "stop_dels_frac":  1.0,
    ...              "phet": 0.0,
    ...              "p_del": 0.01,
    ...              "lam_del": 10,
    ...              "del_loc_rng_seed": 3,
    ...              "del_len_sub_rng_seed": 4
    ...          }
    ...      }
    ...  }, open('README-DATA/mutations3.json','w'), indent=2)

Let's take a look at the resulting VCF file:

    >>> shell('python mutate.py --paramfile=README-DATA/mutations3.json')
    >>> with open('README-DATA/variants.vcf','r') as f: print f.read()  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ##fileformat=VCFv4.1
    ##fileDate=...
    ##source=...
    ##reference=porcine_circovirus_0.smalla
    #CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  sample
    1       102     .       CCGTTACCGC      C       96      PASS    .       GT      1/1
    1       196     .       TCCTGGG T       96      PASS    .       GT      1/1
    1       283     .       TACTACAG        T       96      PASS    .       GT      1/1
    1       361     .       AGTGCTGTTA      A       96      PASS    .       GT      1/1
    1       465     .       CTACCACTCC      C       96      PASS    .       GT      1/1
    1       570     .       TGGAAATGTA      T       96      PASS    .       GT      1/1
    1       663     .       CAGAGAA C       96      PASS    .       GT      1/1
    <BLANKLINE>

If we put these two sets of mutations together, we can see that the SNP at 374 would overlap with the delete starting at
361 and the SNP at 472 would come right after the delete at 465. The SNP at 570 would come right before the delete at
570. For purposes of clarity (see below) we like to have at least a one base gap between mutations.

When we ask `mutate.py` for both these sets of mutations (keeping the same random seeds),

    >>> json.dump(
    ... {
    ...      "input smalla file": "README-DATA/porcine_circovirus_0.smalla",
    ...      "output vcf file": "README-DATA/variants.vcf",
    ...      "chromosome": "1",
    ...      "mutations": {
    ...          "snp": {
    ...              "model": "snp",
    ...              "start_snps_frac": 0.0,
    ...              "stop_snps_frac":  1.0,
    ...              "phet": 0.0,
    ...              "p": 0.01,
    ...              "poisson_rng_seed": 1,
    ...              "base_sub_rng_seed": 2
    ...          },
    ...          "delete": {
    ...              "model": "delete",
    ...              "start_dels_frac": 0.0,
    ...              "stop_dels_frac":  1.0,
    ...              "phet": 0.0,
    ...              "p_del": 0.01,
    ...              "lam_del": 10,
    ...              "del_loc_rng_seed": 3,
    ...              "del_len_sub_rng_seed": 4
    ...          }
    ...      }
    ...  }, open('README-DATA/mutations4.json','w'), indent=2)

we get:

    >>> shell('python mutate.py --paramfile=README-DATA/mutations4.json')
    >>> with open('README-DATA/variants.vcf','r') as f: print f.read()  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ##fileformat=VCFv4.1
    ##fileDate=...
    ##source=...
    ##reference=porcine_circovirus_0.smalla
    #CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  sample
    1       99      .       C       G       96      PASS    .       GT      1/1
    1       102     .       CCGTTACCGC      C       96      PASS    .       GT      1/1
    1       187     .       A       C       96      PASS    .       GT      1/1
    1       196     .       TCCTGGG T       96      PASS    .       GT      1/1
    1       277     .       T       C       96      PASS    .       GT      1/1
    1       283     .       TACTACAG        T       96      PASS    .       GT      1/1
    1       361     .       AGTGCTGTTA      A       96      PASS    .       GT      1/1
    1       374     .       T       A       96      PASS    .       GT      1/1
    1       465     .       CTACCACTCC      C       96      PASS    .       GT      1/1
    1       570     .       T       C       96      PASS    .       GT      1/1
    1       657     .       A       G       96      PASS    .       GT      1/1
    1       663     .       CAGAGAA C       96      PASS    .       GT      1/1


Mutate resolves the conflicts between the mutations and ensures they don't clash.

Also note that we've kept all our random number generators independent. This allows us greater control over the data
we generate and allows us to avoid unexpected interactions between all our variables.

Generating reads
================

In the previous section we learned how to use `mutate.py` to generate a VCF file with simulated variants representing
a mutated sequence. We would, eventually, like to simulate reads from this mutated sequence. This is a two step process.
In the first step we use `vcf2seq.py` to write out the mutated sequence by combining the reference sequence with the
VCF file. `vcf2seq.py` also writes out a `pos` (position) file. In the next step we invoke `reads.py` to actually
generate the reads. Just like `mutate.py` has different variant generating models `reads.py` has different read generating
models simulating the read characteristics of different machines. **For every read we generate we store POS and CIGAR
strings that correspond to a perfect alignment. We can use this to diagnose performance and errors in aligners and
variant callers**. The POS and CIGAR are written into the qname field of the read and are easily extracted. The simple
program `cheata.py` will generate a perfect alignment for you from a simulated .bam file produced by `reads.py`


vcf2seq
-------
Running vcf2seq will generate a mutated sequence and a `.pos` file that contains important indexing information used by
`reads.py`.

    >>> shell('python vcf2seq.py README-DATA/porcine_circovirus_0.smalla README-DATA/pc_mutated 1 README-DATA/variants.vcf.gz  --ploidy=2')

This generates two sequences `pc_mutated_0.smalla` and  having all the mutations described in the VCF file above. Using
a pen and paper we can work out what the mutated sequence should look like:

                                                                                                    C -> G                                                                                  A -> C                                                                                    T -> C                                                                                                                                                                                                                                                                                               T -> C                                                                                 A -> G
                                                                                                      |                                                                                       |                                                                                         |                                                                                                                                                                                                                                                                                                    |                                                                                      |
    ATGACGTATCCAAGGAGGCGTTACCGGAGAAGAAGACACCGCCCCCGCAGCCATCTTGGCCAGATCCTCCGCCGCCGCCCCTGGCTCGTCCACCCCCGCCACCGTTACCGCTGGAGAAGGAAAAACGGCATCTTCAACACCCGCCTCTCCCGCACCTTCGGATATACTATCAAGCGAACCACAGTCAAAACGCCCTCCTGGGCGGTGGACATGATGAGATTCAATATTAATGACTTTCTTCCCCCAGGAGGGGGCTCAAACCCCCGCTCTGTGCCCTTTGAATACTACAGAATAAGAAAGGTTAAGGTTGAATTCTGGCCCTGCTCCCCGATCACCCAGGGTGACAGGGGAGTGGGCTCCAGTGCTGTTATTCTAGATGATAACTTTGTAACAAAGGCCACAGCCCTCACCTATGACCCCTATGTAAACTACTCCTCCCGCCATACCATAACCCAGCCCTTCTCCTACCACTCCCGCTACTTTACCCCCAAACCTGTCCTAGATTCCACTATTGATTACTTCCAACCAAACAACAAAAGAAATCAGCTGTGGCTGAGACTACAAACTGCTGGAAATGTAGACCACGTAGGCCTCGGCACTGCGTTCGAAAACAGTATATACGACCAGGAATACAATATCCGTGTAACCATGTATGTACAATTCAGAGAATTTAATCTTAAAGACCCCCCACTTAACCCTTAG
                                                                                                          ------------                                                                                  ---------------------                                                                  -------                                                                       -------------                                                                                           ------                                                                                                                                                                                                -----------
                                                                                                              del                                                                                                del                                                                             del                                                                              del                                                                                                  del                                                                                                                                                                                                     del

    --> work this out again

and compare it to the generated one

    >>> with open('README-DATA/pc_mutated_0.smalla','r') as f: print f.read()
    ATGACGTATCCAAGGAGGCGTTACCGGAGAAGAAGACACCGCCCCCGCAGCCATCTTGGCCAGATCCTCCGCCGCCGCCCCTGGCTCGTCCACCCCCGGCACTGGAGAAGGAAAAACGGCATCTTCAACACCCGCCTCTCCCGCACCTTCGGATATACTATCAAGCGAACCACAGTCCAAACGCCCTCGGTGGACATGATGAGATTCAATATTAATGACTTTCTTCCCCCAGGAGGGGGCTCAAACCCCCGCTCTGTGCCCCTTGAATAATAAGAAAGGTTAAGGTTGAATTCTGGCCCTGCTCCCCGATCACCCAGGGTGACAGGGGAGTGGGCTCCATTCAAGATGATAACTTTGTAACAAAGGCCACAGCCCTCACCTATGACCCCTATGTAAACTACTCCTCCCGCCATACCATAACCCAGCCCTTCTCCCGCTACTTTACCCCCAAACCTGTCCTAGATTCCACTATTGATTACTTCCAACCAAACAACAAAAGAAATCAGCTGTGGCTGAGACTACAAACTGCCGGAAATGTAGACCACGTAGGCCTCGGCACTGCGTTCGAAAACAGTATATACGACCAGGAATACAATATCCGTGTAACCATGTATGTGCAATTCTTTAATCTTAAAGACCCCCCACTTAACCCTTAG

reads
-----
We first create a parameter file. Note that we want to simulate reads from a diploid organism and so we pass in two
file names under `input_sequences`. This element (alongwith `total_reads` and `read_ranges`) must always be a list.

    >>> json.dump(
    ... {
    ...     "input_sequences": ["README-DATA/pc_mutated_0.smalla", "README-DATA/pc_mutated_1.smalla"],
    ...     "total_reads": [100, 100],
    ...     "is_this_ref_seq": False,
    ...     "read_ranges": [[0.0, 1.0], [0.0, 1.0]],
    ...     "output_file_prefix": "README-DATA/sim_reads",
    ...     "read_model": "tiled_reads",
    ...     "model_params": {
    ...         "paired": False,
    ...         "read_len": 100,
    ...         "template_len": 250,
    ...         "read_advance": 50
    ...     }
    ... }, open('README-DATA/read_par.json','w'), indent=2)


Now we run `reads.py` with an appropriate read parameter file to generate a bucket of reads.

    >>> shell('python reads.py  --paramfile=README-DATA/read_par.json  --corrupt')

This produces a BAM file (`sim_reads.bam`) with perfect reads from the mutated sequence. Because of the `--corrupt` option it
also produces `sim_reads_c.bam` which has corrupted reads. This uses the stock plugin which generates errors at the
inner ends of the reads with an exponential envelope.

Note that if we wanted to generate reads from a reference sequence we would simply feed `reads.py` with the sequence.

cheata
------
We can run `cheata.py`on this BAM file to generate perfect alignment

    >>> shell('python cheata.py --inbam=README-DATA/sim_reads.bam --outbam=README-DATA/aligned.bam  --heada=README-DATA/porcine_circovirus_0.smalla.heada')

Now you can use `samtools tview` or `tablet` or `IGV` to open up `aligned.bam` and see the perfectly aligned assembly of
the data.

You can repeat the process with the corrupted reads to get a perfectly aligned BAM but with simulated corruption in the
reads.

    >>> shell('python cheata.py --inbam=README-DATA/sim_reads_c.bam --outbam=README-DATA/aligned_c.bam  --heada=README-DATA/porcine_circovirus_0.smalla.heada')


Testing `samtools mpileup`
=========================
Having done these steps, we can now test the `samtools mpileup` function and see if we can find back the variants we
put into the mutated sequence from which we just generated reads.

We first run `mpileup` on the perfect alignment

    >>> shelly('samtools mpileup -uf Data/porcine_circovirus.fa README-DATA/aligned.bam | bcftools view -bvcg - > README-DATA/var.raw.bcf')
    >>> shelly('bcftools view README-DATA/var.raw.bcf | vcfutils.pl varFilter -D100 > README-DATA/mpileup.vcf')

Then we compare the original VCF with  the detected one

    >>> shell('tail -n -11 README-DATA/variants.vcf')
    >>> shell('tail -n -11 README-DATA/mpileup.vcf')

The VCF entries should indicate identical variants from the `mpileup` command as we generated in the simulation.


Testing BWA alignment
=====================
How about using `reads.py` to generate some reads from a reference sequence and then checking how well a commonly used
aligner can align the reads?

    >>> shell('python converta.py Data/adenovirus.fa README-DATA/adenovirus')
    >>> json.dump(
    ... {
    ...     "input_sequences": ["README-DATA/adenovirus_0.smalla"],
    ...     "coverages": [10.0],
    ...     "is_this_ref_seq": True,
    ...     "read_ranges": [[0.0, 1.0]],
    ...     "output_file_prefix": "README-DATA/adeno_reads",
    ...     "read_model": "simple_reads",
    ...     "model_params": {
    ...         "paired": True,
    ...         "read_len": 10,
    ...         "template_len": 250,
    ...     }
    ... }, open('README-DATA/adeno_read_par.json','w'), indent=2)
    >>> shell('python reads.py  --paramfile=README-DATA/adeno_read_par.json')
    >>> shelly('samtools bam2fq README-DATA/adeno_reads.bam > README-DATA/raw_reads.fq')
    >>> shell('bwa index Data/adenovirus.fa')
    >>> shelly('bwa mem -p Data/adenovirus.fa README-DATA/raw_reads.fq > README-DATA/adeno_aligned.sam')
    >>> shelly('samtools view -Sb README-DATA/adeno_aligned.sam > README-DATA/temp.bam')
    >>> shell('samtools sort README-DATA/temp.bam README-DATA/adeno_aligned')
    >>> shell('samtools index README-DATA/adeno_aligned.bam')
    >>> shell('python cheata.py split --inbam=README-DATA/adeno_aligned.bam')
    >>> shell('python Analysis/diagnose_alignment.py --correctbam=README-DATA/adeno_aligned_correct.bam --wrongbam=README-DATA/adeno_aligned_wrong.bam  --smalla=README-DATA/adenovirus_0.smalla  --outpkl=README-DATA/bwa_adenovirus_stats.pkl  --outfig=README-DATA/bwa_adenovirus_stats.png')

You should end up with a page of plots telling you how well the aligner did its job

![Aligner summary figure]: (README-DATA/bwa_adenovirus_stats.png)


For further examples of what Mitty can do for you, please refer to the `Examples` directory and the `Readme.md`
file there to read along. For each of the programs listed above please run the `-h` option to learn the usage pattern.


Installation
============

There are two branches in the repository:

    master - stable working code
    dev    - code could be unstable/unworking but will have the latest experimental stuff going on

The code requires the following non-standard modules

    BioPython   - pip install biopython --user
    PyVCF       - pip install pyvcf --user
    pysam       - pip install pysam -- user

The code requires the following external tools to run the examples

    bgzip       - to compress VCF file
    tabix       - to index VCF file
    samtools    - indexing fasta and converting between bam and sam etc
    bwa         - alignments etc.



Subdirectories
--------------
    Params      - example parameter files for mutate.py and reads.py
    Recipes     - snippets of code (shell scripts and python scripts) to do/show particular tasks. useful for devs and
                  users alike
    Data        - test data for the programs
    Plugins     - directory where simulation models are stored


Files and formats
-----------------

## VCF

`vcf2seq.py` currently handles a specific interpretation of the VCF. In the most liberal interpretation of the VCF the
REF sequence corresponds to bases matching the reference starting at POS and those bases are replaced by the bases found
in ALT. Any number of bases in ALT may match the REF in any place (though this is not very useful to us).

Mitty has a more strict interpretation of the VCF. In Mitty's interpretation, at most, the first base
of REF will match with ALT. All other bases must be different. All variants can be coded in this manner:

Say our original sequence is `ATCGGATC`

                 POS   REF     ALT
    Deletion      1   ATCG     A     -> AGATC
    Deletion      2   TCG      .     -> AGATC     (Though this form is interpreted by vcf2seq it is never produced by mutate.py)
    Deletion      1    A       .     -> TCGGATC
    Insertion     0    .      TTT    -> TTTATCGGATC
    Insertion     1    A      AGGG   -> AGGGTCGGATC
    SNP           1    A       G     -> GTCGATC

In addition to this Mitty adds an additional code to the genotype (GT) field 1/0. This is because in the simulation we
have actual access to which copy of a diploid sequence has a heterozygous mutation. Therefore we use the GT field to
encode on which set of the sequence the variant exists. Note that VCF files produced by Mitty never have 0/0 as we do
not include any standard variant from a library.

## "Buffer bases" between simulated variants

If we have variants adjacent to each other the most parsimonious description of the resulting variation can be different
from the original variants.

For example, considering `M=ATCGATCG` and an insertion and deletion as follows

    POS REF ALT
    1   A   ACC
    1   AT  A

We get

         1  2345678
    R    A  TCGATCG
    M    ACC CGATCG

This can, actually, be most parsimoniously expressed as

         1 2345678
    R    A TCGATCG
    M    ACCCGATCG

Which is a single base insertion followed by a SNP

    POS REF ALT
    1   A  AC
    2   T  C

For reasons of such ambiguity Mitty places a minimum 1 base "buffer" between variants, making the generated variant
identical to the most parsimonious description.


Dev notes
=========

Plugin system for simulation models
-----------------------------------

Mitty implements models for variant and read simulation as Python modules located in the Plugins directory. The modules
need to expose a few key functions that `mutate.py` and `reads.py` use to determine variant and read characteristics.
Mitty infers the module name from the name given in the parameter .json file. Mitty comes with some stock models for
variant and read simulation which can be used as example code.

### Random number generators, blocked computation etc.
You will note that the stock plugins accept one or more inputs that serve as seeds for internal random number
generators. These seeds need to be specified in the simulation parameter files and ensure reproducibility of
simulations.

Some of the models use several, independently seeded, random number generators for different variables (e.g.
insertion length and insertion position) to avoid unexpected interactions between such simulated variables. The
algorithms are also designed such that the simulation results are independent of block size.


Algorithms
----------
### Variants, reads and CIGARS
One big goal of Mitty is to serve up realistic test data for bioinformatics algorithms, from aligners to variant
callers. Testing whether a variant caller is correctly working on the simulated data is relatively easy: we simply
compare the variant caller's VCF file with the answer book VCF generated by Mitty. It is, however, slightly more involved
to deduce if an aligner is correctly aligning the simulated reads, and to diagnose how the performance of an aligner is
affecting the accuracy of a variant caller. To this end Mitty has a system to compute the correct read position and
CIGAR for each simulated read. This information is stored in the read's qname string so that it is easily accessible
to diagnostic programs.

In order to generate reads based on a given VCF file and a reference sequence we go through a two step process.
We first generate the mutated sequence (`mut_seq`) along with some other information that encodes the difference between
each base in the `mut_seq` and corresponding positions on the `ref_seq`. We then generate reads from the `mut_seq` using
the sidecar information to compute the correct POS values and CIGAR strings for the reads.

The algorithm is best introduced through a series of examples. In the examples the reference sequence is labelled `R` and
the mutated sequence is labeled `M`. The information for setting the POS and CIGAR for the read is taken from an
array `pos` that accompanies `M`

#### Generating `pos`

Let `R = ACTGACTG`

Consider a single base insertion at position 1

    POS REF ALT
    1   A   AT

         1 2345678
    R    A CTGACTG
    M    ATCTGACTG
    pos  1223456789


Consider a multiple base insertion at position 1

    POS REF ALT
    1   A   ATT

         1  2345678
    R    A  CTGACTG
    M    ATTCTGACTG
    pos  12223456789


Consider a multiple base insertion at last position

    POS REF ALT
    8   G   GTT

         12345678
    R    ACTGACTG
    M    ACTGACTGTT
    pos  12345678999

Consider a multiple base deletion

    POS REF ALT
    2   CTG  C

         12345678
    R    ACTGACTG
    M    AC  ACTG
    pos  12  56789

Consider a SNP, an insertion and a deletion

    POS REF ALT
    2   C   T
    4   G   GTT
    6   CTG C

         1234  5678
    R    ACTG  ACTG
    M    ATTGTTAC
    pos  123455569


`pos` is generated by copying over the index from `R`. When we encounter an insertion we copy over the index of the next
reference base as many times as there is an insertion. Deletions are simply skipped. For the purposes of computing `pos`
we also add an imaginary base position at the end of the reference sequence (9 in this case)

You can "read along" to these examples by running `python vcf2seq.py test -v` and seeing how different functions in
`vcf2seq.py` implement these algorithms

#### Generating CIGARS and POS for reads from `pos`
Consider our last example and some reads from `M`

         1234  5678
    R    ACTG  ACTG
    M    ATTGTTAC
    pos  123455569
         ++++---------> POS = 1 (The first pos value we encounter)
                        CIGAR = 4M  (2-1=1 -> 1M
                                     3-2=1 -> 1M
                                     4-3=1 -> 1M
                                     5-4=1 -> 1M)

    M    ATTGTTAC
    pos  123455569
          ++++--------> POS = 2 (The first pos value we encounter)
                        CIGAR = 3M1I  (3-2=1 -> 1M
                                       4-3=1 -> 1M
                                       5-4=1 -> 1M
                                       5-5=0 -> 1I)

    M    ATTGTTAC
    pos  123455569
           ++++-------> POS = 3
                        CIGAR = 2M2I  (4-3=1 -> 1M
                                       5-4=1 -> 1M
                                       5-5=0 -> 1I
                                       5-5=0 -> 1I)

    M    ATTGTTAC
    pos  123455569
             ++++-----> POS = 5
                        CIGAR = 2I2M  (5-5=0 -> 1I
                                       5-5=0 -> 1I
                                       6-5=1 -> 1M
                                       9-6=3 -> 1M + 2D) The D only comes into play if our read crosses the deletion

To see how a deletion affects our POS and CIGAR consider another previous example

    POS REF ALT
    2   CTG  C

         12345678
    R    ACTGACTG
    M    AC  ACTG
    pos  12  56789
         ++  ++-------> POS = 1
                        CIGAR = 2M2D2M  (2-1=1 -> 1M
                                         5-2=3 -> 1M + 2D The 2D comes into play because the read crosses the boundary
                                         6-5=1 -> 1M
                                         7-6=1 -> 1M)

Example of an unmapped read

    POS REF ALT
    2   C  CAATTGG

         12      345678
    R    AC      TGACTG
    M    ACAATTGGTGACTG
    pos  123333333456789
           ++++-------> POS = 3
                        CIGAR = 4I  (3-3=0 -> 1I
                                     3-3=0 -> 1I
                                     3-3=0 -> 1I
                                     3-3=0 -> 1I)
    For a read to be mapped, there has to be at least one M. Since there are no Ms we discard the POS and CIGAR as this
    is an unmapped read

`reads.py` generates simulated reads from `mut_seq` based on the read model. Using the `pos` arrays it
also generates appropriate alignment information (POS and CIGAR) that is stored in the qname string.
(Note that while the BAM specs do not place a limit on the length of the qname string both Tablet and IGV expect a
string with length < 255 characters. It is possible that the qname will exceed this and you won't be able to open a
set of simulated reads using tools that arbitrarily limit the qname). If no `pos` file is supplied `reads.py` assumes
we are taking reads from a reference sequence and the POS values are actual positions of the reads and all the cigars
are of the form `100M` (For e.g. 100 base reads).

Computing POS: For every read, the POS value is simply the index from `pos` corresponding to the first base of the read
EXCEPT for unmapped reads.

Computing the CIGAR:

1. Initialize the base counter to `None`, set mapped flag to `False`
2. Step through the each base of the read and look at the difference in `pos` values `dp`
3. If `dp==1`, if the counter is any thing other than `M`, flush it. Set or increment counter as `M`. Set mapped flag to `True`
4. If `dp==0`, if the counter is other than `I`, flush it. Set or increment counter as `I`
5. If `dp>1`, if the counter is other than `M`, flush it. Set and flush counter as `M`, set counter as `D` to be dp-1
6. Continue from 2 until done.
7. Flush any counter other than `D`
8. If the mapped flag is `False` reset POS and CIGAR - this is an unmapped read.

You can "read along" to these examples by running `python reads.py test -v` and seeing how different functions in
`reads.py` implement these algorithms


Misc design choices
--------------
### Choice to output a mutated sequence as a whole
Though generating a whole mutated sequence uses a lot of disk space, I chose this approach as it ended up being simpler
than coming up with an algorithm for generating reads on the fly based ona  VCF file. In the future the code may be
converted to do on the fly generation.

### Parameter files for mutate
1. I chose to use parameter files because we often want to rerun experiments and it became clear early on that there would
be a lot of parameters.
1. I chose to use python for the parameter file for parsimony and flexibility
1. The parameter distribution between file and command line was based on predictions of which parameters we could
experiment with most during testing
1. At this time I do not know whether having everything on the commandline would be better for PIPITOR or if param files
are preferred for Platform integration, but either way is a short code reorganization that can be done quickly at the
time of integration.

### POS files
These are simple binary files carrying unsigned 4 byte int information. This is enough to handle index/index diff sizes
for human genome sizes, though if we ever work on heavily mutated specimens of the loblolly pine, perhaps we have to
go to 8 byte ints ...


Whole genome file
-----------------

    Header-----------------------------------------------
    [char10]  - version of whole genome file
    [char255] - Human readable species etc
    [uint8]   - number of chromosomes
    [uint8]   - ploidy of the *data* (1,2,3 ...)

    Index-------------------------------------------------
    For each chromosome--------------------------
        [uint8]   - chromosome number
        [char255] - Human readable description
        [char255] - NCBI accession string (if any)
        For each copy------------------------------
            [uint32]  - start of data in this file
            [uint32]  - length of sequence

    Data--------------------------------------------------
    For each chromosome--------------------------
        For each copy------------------------------
            [uchar]   - Nucleotide data
              ...

Python's native mmap can't do proper offsets ... should we use numpy?


Trivia
======
Since you were dying to know: Mitty comes from James Thurber's "[The Secret Life of Walter Mitty][mitty]" one of my
favourite pieces from one of my favourite authors. Though [Wikipedia][wiki] has a less favourable interpretation of what
Walter Mitty stands for, I always thought that Thurber was celebrating the dreamer within each us who spices up the banal
parts of life with a little harmless fantasy.

[mitty]: http://www.newyorker.com/archive/1939/03/18/390318fi_fiction_thurber?currentPage=all
[wiki]: http://en.wikipedia.org/wiki/The_Secret_Life_of_Walter_Mitty