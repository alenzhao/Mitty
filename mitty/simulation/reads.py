"""Contains the logic for handling read model invocation, read creation and writing"""

__qname_format__ = '@read_serial|chrom|copy|strand|pos|rlen|cigar|vs1,vs2,...|strand|pos|rlen|cigar|vs1,vs2,...'
__qname_format_details__ = """
@read_serial|chrom|copy|strand|pos|rlen|cigar|vs1,vs2,...|strand|pos|rlen|cigar|vs1,vs2,...
    |          |     |    |     |    |    |        |         |                      |
 unique        |     |    |     | read    |        |         ---- repeated for ------
 number for    |     |    |     | len     |        |          other read in template
 template      |     |    |     |         |        |
               |     |    |     |     cigar    comma separated
      chrom read     |    |     |              list of sizes of
  was taken from     |    |     |              variants this read
       One based     |    |     |              covers
                     |    |     |
                     |    |     |
    copy of chrom read    |     |
  was taken from (1,2)    |     |
                          |     |
         forward strand (0)     |
      or reverse strand (1)     |
                                |
                      pos of read
                        One based

The chrom and pos are one based to make comparing qname info in genome browser easier

For reads from inside a long insertion the CIGAR has the following format:

  '>p:nI'

where:

 '>' is the unique key that indicates a read inside a long insertion
 'p' is how many bases into the insertion branch the read starts
 'n' is simply the length of the read
"""
import time

import pysam
import numpy as np

import logging

logger = logging.getLogger(__name__)



DNA_complement = str.maketrans('ATCGN', 'TAGCN')

# Will hold the mem-shared read only data
template_list = None
vcf_df = None


def generate_template_list(fasta_fname, bed_fname=None, read_model=None, seed=7):
  """Saves the template list generated by the read model to the  global variable 'template_list'

  :param fasta_fname:
  :param bed_fname:
  :param read_model:
  :param seed:
  :return:
  """
  fasta = pysam.FastaFile(fasta_fname)
  bed = get_regions(fasta, bed_fname=bed_fname)

  logger.debug('Divided genome into {} regions'.format(len(bed)))
  logger.debug('Generating templates ...')
  t0 = time.time()

  global template_list
  template_list = read_model.generate_templates(bed, seed=seed)

  t1 = time.time()
  t_cnt = sum(t['reads'].shape[0] for t in tpl)
  logger.debug('... generated {} templates in {}s ({} tplt/s)'.format(t_cnt, t1 - t0, t_cnt / (t1 - t0)))


def read_vcf(vcf_name, sample_name):
  global vcf_df
  vcf_df = read_sample_from_vcf(fname, sample)

def generate_reads_for_subregion(fasta_fname, region):
  """Given a fasta file name and a region, grab that part of the sequence, trim out the relevant part of the VCF,
  apply variants to create the node representation of the sample, then generate reads"""

  pass







def get_regions(fasta, bed_fname=None):
  """Parse the BED file. If none is supplied, make very simple regions based on the sequences present in the FASTA

  :param fasta: as returned by pysam.FastaFile
  :param bed_fname:
  :return:
  """
  if bed_fname is not None:
    return list(map(lambda x: (x[0], int(x[1]), int(x[2])), map(lambda x: x.split(), open(bed_fname, 'r').readlines())))

  return [
    (r, 1, l)
    for r, l in zip(fasta.references, fasta.lengths)
  ]


def validate_templates_from_read_model(tplt):
  """A series of tests to make sure that the returned template locations are in a format suitable for our use

  :param tplt:
  :return:
  """
  if not isinstance(tplt, list):
    raise RuntimeError('Read model should return a list')

  if not isinstance(tplt[0], dict):
    raise RuntimeError('Read model should return a list of dicts')

  for k in ['reads', 'region']:
    if k not in tplt[0]:
      raise RuntimeError('Read model dict should contain {}'.format(k))

  if not isinstance(tplt[0]['reads'], np.recarray):
    raise RuntimeError('Reads should be in the form of a numpy recarray')



